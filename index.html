<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>å‘½è¿ä¹‹è½® - æ²‰æµ¸å¼æ‰‹åŠ¿å¡”ç½—</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 90%); 
            font-family: 'Cinzel', serif; 
            color: #d4af37; /* é‡‘è‰² */
        }

        /* æ‘„åƒå¤´ç”»ä¸­ç”» - åŠ ä¸Šé‡‘è‰²è¾¹æ¡† */
        #camera-container {
            position: absolute; top: 20px; left: 20px;
            width: 160px; height: 120px; z-index: 10;
            border: 3px solid #d4af37; 
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            border-radius: 4px; overflow: hidden;
            transform: scaleX(-1); opacity: 0.8;
            transition: opacity 0.5s;
        }
        video { width: 100%; height: 100%; object-fit: cover; filter: sepia(0.5) contrast(1.2); }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        #header {
            position: absolute; top: 20px; width: 100%; text-align: center;
            pointer-events: none; z-index: 5;
        }
        h1 { margin: 0; font-size: 32px; letter-spacing: 5px; text-shadow: 0 0 20px #d4af37; }

        /* åº•éƒ¨çŠ¶æ€æ  */
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            pointer-events: none; z-index: 5;
        }
        #status { 
            font-size: 20px; letter-spacing: 2px;
            background: rgba(0,0,0,0.6); padding: 10px 30px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            display: inline-block; border-radius: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        /* é˜µæ³•ä½ç½®æ ‡ç­¾ (è¿‡å»/ç°åœ¨/æœªæ¥) */
        .slot-label {
            position: absolute; top: 65%; transform: translateX(-50%);
            font-size: 18px; color: #fff; opacity: 0;
            text-shadow: 0 0 10px #d4af37;
            transition: opacity 1s, top 1s;
        }
        /* åŠ¨æ€ç”Ÿæˆä¸‰ä¸ªæ ‡ç­¾çš„ä½ç½® */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="header"><h1>TAROT OF FATE</h1></div>

    <div id="camera-container">
        <video id="input_video"></video>
    </div>

    <div id="labels-container"></div> <div id="ui-layer">
        <div id="status">âœ¨ æ­£åœ¨è¿æ¥çµæ€§é€šé“ (å¯åŠ¨æ‘„åƒå¤´)...</div>
    </div>

<script>
    // --- 0. éŸ³æ•ˆåˆæˆå™¨ (Web Audio API) ---
    // ä¸ºäº†ä¸ä¾èµ–å¤–éƒ¨mp3æ–‡ä»¶ï¼Œæˆ‘ä»¬ç”¨ä»£ç ç”Ÿæˆ"é­”æ³•"éŸ³æ•ˆ
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playMagicSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === 'hover') {
            // é€‰ç‰Œ: é«˜é¢‘é£é“ƒå£°
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        } else if (type === 'select') {
            // ç¡®è®¤æŠ½å–: ç¥ç§˜çš„é—ªçƒå£°
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(880, now + 0.3);
            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
            
            // å¢åŠ å›å£°æ„Ÿ
            filter.type = "lowpass";
            filter.frequency.value = 2000;
            
            osc.start(now);
            osc.stop(now + 1.5);
        } else if (type === 'flip') {
            // ç¿»ç‰Œ: ç©ºæ°”åˆ’è¿‡çš„å£°éŸ³ (æ¨¡æ‹Ÿç™½å™ªéŸ³)
            // ç®€å•æ¨¡æ‹Ÿ: ä½é¢‘æ»‘éŸ³
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            filter.type = "lowpass";
            filter.frequency.setValueAtTime(500, now);
            filter.frequency.linearRampToValueAtTime(100, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        }
    }

    // --- 1. Three.js åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a0b2e, 0.04); // ç´«è‰²è¿·é›¾

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 4, 11);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // ç¯å…‰ç³»ç»Ÿ
    const ambLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambLight);
    
    // ä¸»å…‰æºï¼šé‡‘è‰²èšå…‰ç¯
    const spotLight = new THREE.SpotLight(0xffeebb, 1);
    spotLight.position.set(0, 20, 10);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.5;
    spotLight.castShadow = true;
    scene.add(spotLight);

    // ç´«è‰²èƒŒå…‰ï¼Œå¢åŠ ç¥ç§˜æ„Ÿ
    const purpleLight = new THREE.PointLight(0x8a2be2, 1, 20);
    purpleLight.position.set(0, 2, -5);
    scene.add(purpleLight);

    // --- 2. æè´¨ç”Ÿæˆå™¨ (ç¨‹åºåŒ–çº¹ç†) ---
    function createCardTexture(type) {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // èƒŒæ™¯
        const grd = ctx.createRadialGradient(128, 256, 20, 128, 256, 256);
        if(type === 'back') {
            grd.addColorStop(0, "#4b0082"); // æ·±ç´«
            grd.addColorStop(1, "#1a0b2e"); // è¿‘é»‘
        } else {
            grd.addColorStop(0, "#fff8dc"); // å¥¶æ²¹è‰²
            grd.addColorStop(1, "#deb887"); // ç¾Šçš®çº¸è‰²
        }
        ctx.fillStyle = grd;
        ctx.fillRect(0,0,256,512);

        // é‡‘è¾¹
        ctx.strokeStyle = "#d4af37";
        ctx.lineWidth = 10;
        ctx.strokeRect(5,5,246,502);
        
        // èŠ±çº¹
        ctx.strokeStyle = "rgba(212, 175, 55, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<512; i+=20) { ctx.moveTo(0,i); ctx.lineTo(256,i+128); }
        ctx.stroke();

        if(type === 'back') {
            // èƒŒé¢ï¼šç”»ä¸€ä¸ªåœ†åœˆ/äº”è§’æ˜Ÿ
            ctx.beginPath();
            ctx.arc(128, 256, 60, 0, 2 * Math.PI);
            ctx.lineWidth = 5;
            ctx.strokeStyle = "#d4af37";
            ctx.stroke();
            // æ–‡å­—
            ctx.fillStyle = "#d4af37";
            ctx.font = "30px serif";
            ctx.textAlign = "center";
            ctx.fillText("FATE", 128, 265);
        } else {
            // æ­£é¢ï¼šéšæœºå›¾æ¡ˆï¼ˆè¿™é‡Œåªç”»ä¸ªå¤§æ¦‚è¡¨ç¤ºï¼‰
            ctx.fillStyle = "#800000";
            ctx.font = "40px serif";
            ctx.textAlign = "center";
            ctx.fillText("TAROT", 128, 100);
            // ç®€å•çš„éšæœºå›¾å½¢
            ctx.beginPath();
            ctx.arc(128, 256, 80, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fill();
        }

        return new THREE.CanvasTexture(canvas);
    }

    // --- 3. åœºæ™¯å¯¹è±¡åˆ›å»º ---
    const cards = [];
    const particles = [];
    const TOTAL_CARDS = 22; 
    const cardGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.02);
    const cardBackTex = createCardTexture('back');
    
    // é˜µæ³•æ§½ä½åæ ‡ (è¿‡å»:å·¦, ç°åœ¨:ä¸­, æœªæ¥:å³)
    const SLOTS = [
        { x: -3.5, y: 1.5, z: 2, label: "THE PAST Â· è¿‡å»" },
        { x: 0,    y: 1.5, z: 2, label: "THE PRESENT Â· ç°åœ¨" },
        { x: 3.5,  y: 1.5, z: 2, label: "THE FUTURE Â· æœªæ¥" }
    ];

    // åˆå§‹åŒ–HTMLæ ‡ç­¾ä½ç½® (DOM)
    function initLabels() {
        const container = document.getElementById('labels-container');
        SLOTS.forEach((slot, i) => {
            const div = document.createElement('div');
            div.className = 'slot-label';
            div.innerText = slot.label;
            div.id = `label-${i}`;
            // ç®€å•çš„2Dä½ç½®æ˜ å°„ï¼Œè¿™é‡Œå…ˆå±…ä¸­éšè—ï¼Œç­‰é€‰ä¸­åæ˜¾ç¤º
            div.style.left = '50%';
            div.style.top = '60%';
            container.appendChild(div);
        });
    }
    initLabels();

    // åˆ›å»ºå¡ç‰Œ
    for (let i = 0; i < TOTAL_CARDS; i++) {
        // æ¯å¼ ç‰Œæ­£é¢ç•¥å¾®ä¸åŒï¼ˆéšæœºç”Ÿæˆä¸€ä¸ªçº¹ç†ï¼‰
        const frontTex = createCardTexture('front'); 
        
        const materials = [
            new THREE.MeshStandardMaterial({ color: 0x111111 }), // ä¾§è¾¹
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ color: 0x111111 }),
            new THREE.MeshStandardMaterial({ map: frontTex }),   // æ­£é¢
            new THREE.MeshStandardMaterial({ map: cardBackTex }) // èƒŒé¢
        ];
        
        const card = new THREE.Mesh(cardGeometry, materials);
        card.position.set(0, -2, -i * 0.05); // åˆå§‹åœ¨å±å¹•ä¸‹æ–¹å †å 
        card.rotation.set(-Math.PI / 2, 0, Math.random() * 0.2 - 0.1);
        card.castShadow = true;
        card.receiveShadow = true;
        
        card.userData = { id: i, isSelected: false };
        cards.push(card);
        scene.add(card);
    }

    // --- 4. ç²’å­ç³»ç»Ÿ (é­”æ³•å…‰å°˜) ---
    // åˆ›å»ºä¸€ä¸ªå…¨å±€çš„ç²’å­ç³»ç»Ÿï¼Œè€Œä¸æ˜¯æ¯å¼ å¡ç‰Œä¸€ä¸ª
    const particleGeo = new THREE.BufferGeometry();
    const particleCount = 300;
    const pPos = new Float32Array(particleCount * 3);
    const pVel = [];
    
    for(let i=0; i<particleCount; i++){
        pPos[i*3] = (Math.random() - 0.5) * 20;
        pPos[i*3+1] = (Math.random() - 0.5) * 10;
        pPos[i*3+2] = (Math.random() - 0.5) * 10;
        pVel.push({
            x: (Math.random()-0.5)*0.02, 
            y: (Math.random()-0.5)*0.02 + 0.02, // å‘ä¸Šæ¼‚æµ®
            z: (Math.random()-0.5)*0.02 
        });
    }
    particleGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const particleMat = new THREE.PointsMaterial({
        color: 0xffd700, size: 0.1, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending
    });
    const magicDust = new THREE.Points(particleGeo, particleMat);
    scene.add(magicDust);


    // --- 5. äº¤äº’é€»è¾‘ & çŠ¶æ€æœº ---
    let appState = 'IDLE'; 
    let drawnCount = 0;
    const selectedCardsData = []; // å­˜å‚¨é€‰ä¸­çš„ç‰Œå’Œå¯¹åº”çš„æ§½ä½ç´¢å¼•
    const uiStatus = document.getElementById('status');

    // çŠ¶æ€æ›´æ–° UI è¾…åŠ©å‡½æ•°
    function updateLabelPos(index) {
        // å°†3Dåæ ‡æŠ•å°„åˆ°2Då±å¹•
        const slot = SLOTS[index];
        const vector = new THREE.Vector3(slot.x, slot.y - 1.5, slot.z); // æ–‡å­—åœ¨å¡ç‰Œä¸‹æ–¹
        vector.project(camera);
        
        const x = (vector.x * .5 + .5) * window.innerWidth;
        const y = (-(vector.y * .5) + .5) * window.innerHeight;

        const el = document.getElementById(`label-${index}`);
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
        el.style.opacity = 1;
    }

    function spreadCards() {
        if (appState !== 'IDLE' && appState !== 'FIST_DETECTED') return;
        appState = 'FANNING';
        uiStatus.innerHTML = "ğŸ´ ç‰Œé˜µå·²å±•å¼€ï¼Œè¯·ä¼¸å‡º<b>é£ŸæŒ‡</b>æ„Ÿåº”ä½ çš„å¡ç‰Œ";
        playMagicSound('select'); // æ’­æ”¾å±•å¼€éŸ³æ•ˆ

        const totalArc = Math.PI * 0.8;
        const radius = 5;
        
        cards.forEach((card, index) => {
            const angle = (index / TOTAL_CARDS) * totalArc - (totalArc / 2);
            // æ‰‡å½¢ä½ç½®
            const tx = Math.sin(angle) * radius;
            const ty = -1; // å±å¹•ä¸‹æ–¹
            const tz = Math.cos(angle) * radius - 5; 
            
            new TWEEN.Tween(card.position).to({ x: tx, y: ty, z: tz }, 1200)
                .easing(TWEEN.Easing.Quadratic.Out).start();
            
            new TWEEN.Tween(card.rotation).to({ x: -0.5, y: -angle, z: 0 }, 1200)
                .start()
                .onComplete(() => {
                    if(index === cards.length -1) appState = 'WAITING_FOR_PICK';
                });
        });
    }

    function pickCard() {
        if (appState !== 'WAITING_FOR_PICK' || drawnCount >= 3) return;
        
        // ç®€å•çš„é˜²æŠ–ï¼šç¡®ä¿ä¸Šæ¬¡åŠ¨ç”»ç¨å¾®å®Œæˆä¸€ç‚¹
        appState = 'PICKING'; 
        
        const available = cards.filter(c => !c.userData.isSelected);
        if (available.length === 0) return;
        
        const card = available[Math.floor(Math.random() * available.length)];
        card.userData.isSelected = true;
        
        // è·å–å½“å‰å¯¹åº”çš„æ§½ä½ï¼ˆè¿‡å»->ç°åœ¨->æœªæ¥ï¼‰
        const slot = SLOTS[drawnCount];
        selectedCardsData.push({ mesh: card, slotIndex: drawnCount });
        
        playMagicSound('select'); // æ’­æ”¾é€‰ä¸­éŸ³æ•ˆ

        // åŠ¨ç”»ï¼šé£å‘æ§½ä½
        new TWEEN.Tween(card.position)
            .to({ x: slot.x, y: slot.y, z: slot.z }, 1500)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();

        new TWEEN.Tween(card.rotation)
            .to({ x: 0, y: 0, z: 0 }, 1500) // ç«–ç›´ï¼Œä¾ç„¶æ˜¯èƒŒé¢
            .start();
        
        // æ”¾å¤§ä¸€ç‚¹
        new TWEEN.Tween(card.scale)
            .to({ x: 1.1, y: 1.1, z: 1.1 }, 1000)
            .onComplete(() => {
                // æ˜¾ç¤ºè¯¥ä½ç½®çš„æ–‡å­—æ ‡ç­¾
                updateLabelPos(drawnCount);
                
                drawnCount++;
                if (drawnCount < 3) {
                    appState = 'WAITING_FOR_PICK';
                    const nextText = drawnCount === 1 ? "ç°åœ¨" : "æœªæ¥";
                    uiStatus.innerHTML = `ğŸ”® å·²é€‰å®š[${SLOTS[drawnCount-1].label.split('Â·')[1].trim()}]ï¼Œè¯·ç»§ç»­æŠ½å– <b>${nextText}</b> ä¹‹ç‰Œ`;
                } else {
                    appState = 'REVEALING';
                    uiStatus.innerHTML = "âœ¨ å‘½è¿ä¹‹è½®å·²å®šï¼Œå‡†å¤‡æ­æ™“...";
                    setTimeout(revealAll, 1000);
                }
            })
            .start();
    }

    function revealAll() {
        selectedCardsData.forEach((item, i) => {
            setTimeout(() => {
                playMagicSound('flip'); // ç¿»ç‰ŒéŸ³æ•ˆ
                new TWEEN.Tween(item.mesh.rotation)
                    .to({ y: Math.PI }, 1200) // ç¿»è½¬
                    .easing(TWEEN.Easing.Back.Out)
                    .start();
            }, i * 500); // ä¾æ¬¡ç¿»å¼€
        });
        uiStatus.innerHTML = "ğŸŒŸ ç‰Œé˜µå·²æˆã€‚è¯·è†å¬å¯ç¤ºã€‚";
        appState = 'FINISHED';
    }


    // --- 6. è§†è§‰æ‰‹åŠ¿è¯†åˆ« ---
    // (é€»è¾‘ä¸ä¸Šä¸€ç‰ˆç±»ä¼¼ï¼Œå¢åŠ äº†çŠ¶æ€åé¦ˆ)
    const videoEl = document.getElementById('input_video');
    
    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
        const lm = results.multiHandLandmarks[0];

        // ç®€æ˜“åˆ¤æ–­ï¼šé£ŸæŒ‡æ˜¯å¦ä¼¸å‡º (Index Tip y < Index Pip y)
        const isIndexOpen = lm[8].y < lm[6].y; 
        const isMiddleOpen = lm[12].y < lm[10].y;
        const isRingOpen = lm[16].y < lm[14].y;
        const isPinkyOpen = lm[20].y < lm[18].y;

        const isFist = !isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen;
        const isPalm = isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen;
        const isPoint = isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen;

        if (appState === 'IDLE') {
            if(isFist) {
                uiStatus.innerHTML = "âœŠ å·²æ„Ÿåº”èƒ½é‡ï¼ˆæ‹³å¤´ï¼‰ï¼Œè¯·<b>å¼ å¼€æ‰‹æŒ</b>é‡Šæ”¾ç‰Œé˜µ";
                appState = 'FIST_DETECTED';
            } else {
                uiStatus.innerHTML = "è¯·å¯¹ç€é•œå¤´æ¡ç´§<b>æ‹³å¤´</b>ä»¥å¼€å§‹ä»ªå¼";
            }
        } 
        else if (appState === 'FIST_DETECTED' && isPalm) {
            spreadCards();
        }
        else if (appState === 'WAITING_FOR_PICK') {
            if(isPoint) {
                // åŠ ä¸ªå³æ—¶éŸ³æ•ˆåé¦ˆï¼Ÿä¸ï¼Œå¤ªé¢‘ç¹äº†ï¼Œåªåœ¨pickCardé‡Œæ’­æ”¾
                pickCard();
            }
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoEl, {
        onFrame: async () => { await hands.send({image: videoEl}); },
        width: 320, height: 240
    });
    cameraUtils.start();


    // --- 7. æ¸²æŸ“å¾ªç¯ ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        TWEEN.update();

        // 1. å¡ç‰Œæ‚¬æµ®å‘¼å¸æ•ˆæœ (Waiting çŠ¶æ€)
        if(appState === 'WAITING_FOR_PICK') {
            cards.forEach((c, i) => {
                if(!c.userData.isSelected) {
                    c.position.y += Math.sin(time * 2 + i) * 0.002;
                }
            });
        }

        // 2. ç²’å­èƒŒæ™¯æ¼‚æµ®
        const positions = magicDust.geometry.attributes.position.array;
        for(let i=0; i<particleCount; i++){
            positions[i*3+1] += pVel[i].y; 
            // å¾ªç¯å¤ä½
            if(positions[i*3+1] > 10) positions[i*3+1] = -10;
        }
        magicDust.geometry.attributes.position.needsUpdate = true;
        magicDust.rotation.y = time * 0.05; // æ•´ä½“ç¼“æ…¢æ—‹è½¬

        renderer.render(scene, camera);
    }
    animate();

    // çª—å£è°ƒæ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // é‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®
        if(drawnCount > 0) {
           for(let i=0; i<drawnCount; i++) updateLabelPos(i);
        }
    });

</script>
</body>
</html>